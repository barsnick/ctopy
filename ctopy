#!/usr/bin/env python
"""
ctopy -- a quick and dirty C-to-Python translator

Relies on the fact that C and Python have fundamentally similar
expression syntax and control structures, and C is normally indented
in a way that indicates its block structure.  The only parts of
expressions that don't map over without change are ?: and comma
expressions.

You can give it hints.  A hint may be a line in a file pulled in by the -h
option, or tokens in a source file comment beginning with '$ctopy'.  Available
hints are as follows:

	type <name> -- Treat <name> as a scalar type, not requiring
        	initialization except by first assignment.

	class <name> -- Treat name as a class; variables of this type
        	must be initialized by calling the class's contructor
		and assigning the returned value to the variable.

	stringify <name> -- When this name occurs surrounded by word
	 	boundaries, put string quotes around it.  Useful for
		translating enumerated-type values into string literals,
                which Python has as a first-class tyoe.

	printflike <name> -- declarates that a function is like printf;
		its string arguments containing, if any, should be treated
                like printf formats and their arg lists replaced with %
                followed by a tuple containing the args.

Limitations:
    * Requires source to be syntactically valid,
    * Strange indentation (not one of the standard styles) will confuse it.
    * Translates simple kinds of for-loops with a straight increment of
      a loop variable, but not the more complex ones. 
    * Doesn't even attempt to translate switch/case or do/while.
    * Doesn't attempt to translate ternary operator.
    * C comma expressions will spuriously turn into Python tuple constructors,
    * We don't translate frexp and modf because their call conventions differ
      between Python and C, so we want them to throw an error.
    * Enumerations with only some values specified are not yet handled.
"""
import sys, re

stringify = []

printflike = ["printf", "sprintf", "vfprintf"]

shorthands = {
    'id' : r"[a-zA-Z_][a-zA-Z0-9._]*",
    'exp' : r"[a-zA-Z0-9._\-+\*/]+",
    'type' : r"\bvoid\b|\bint\b|\bbool\b|\bchar\b|\bshort\b|\bdouble\b|\blong\b|\bfloat\b|\btime_t\b|\bFILE\b",
    'class' : "\b__dummyclass__\b",
    'ind' : "(\n[ \t]*)",		# Whitespace at start of line
    'eol' : "[ \t]*(?=\n|\Z)",		# Whitespace to end of line or comment
}

# These have to be applied to the entire file without breaking it into regions
file_transformations = (
    # Simple initializers to tuples
    (r"(?:static)?\s+(?:%(type)s|%(class)s)\s+(%(id)s)\[[a-zA-Z0-9._]*]\s*=\s*{([^}]+)}",
     r"\1 = (\2)"),
    (r"enum\s+(%(id)s\s*){\s*",  r"enum \1{\n"),
    (r"enum\s+{\s*",  r"enum {\n"),
    (r"\n#\s*\$ctopy.*", "\n"),	# Make hints go away
    )

# These need to be applied repeatedly within regions.
# They rely on semicolons as statatement end markers.
repeat_transformations = (
    (
    # Group 1: What we're doing here is stripping out prefix, suffix,
    # and wrapper parts of declarations in order to reduce everything
    # to base type followed by whitespace followed by id.  This is
    # significant for simplifying both function formal parameter lists
    # and variable declaration lines.  We'll get rid of the remaining
    # type stuff in a later pass.
    (r"(%(type)s|%(class)s)\s*\*", r"\1 "),	# Pointer type decls
    (r"(%(type)s|%(class)s)\s*\((%(id)s)\)\(\)", r"\1 \2"),	# Function pointer wrappers
    (r"(%(type)s|%(class)s)\s*(%(id)s)\[\]", r"\1 \2"),	# Array declarators
    ),
    (
    # Group 2: Translate function headers.  This needs to happen after
    # reduction to base types (just above) but before scalar types
    # have been removed entirely.
    (r"\n(?:static\s+)?(?:%(type)s|%(class)s) +(.*\)) *\n", r"\ndef \1:\n"),
    ),
    (
    # Group 3: What we're doing here is trying to get rid of variable
    # declarations that don't have initializer parts.
    # Scalar-vars just after the type and before a comma go away.
    (r"(\n[ \t]*(?:%(type)s))(\s*%(id)s),", r"\1"),
    # Scalar-vars just after type and before a semi go away, but semi stays.
    (r"(\n[ \t]*(?:%(type)s))(\s*%(id)s);", r"\1;"),
    # Class-vars after class names and before comma or semi get an initializer.
    (r"(\n[ \t]*)(%(class)s)(\s*%(id)s)([;,])", r"\1\2\3 = \2()\4"),
    # Scalar-vars between a comma and a trailing semicolon go away.
    (r"(\n[ \t]*)((?:%(type)s).*)(,\s*%(id)s\s*);", r"\1\2;"),
    # Class-Vars between comma and semicolon get a following initializer 
    (r"(\n[ \t]*)(%(class)s)(.*,\s)*(%(id)s)(\s*;)", r"\1\2\3\4 = \2()\5"),
    # Scalar-vars between commas in a declaration line go away.
    (r"(\n[ \t]*(?:%(type)s)\s+.*)(,\s*%(id)s)(,.*);", r"\1\3;"),
    # Bare class-vars between commas get an initializer
    (r"(\n[ \t]*)(%(class)s)(\s+.*,)(\s*%(id)s),(.*);",r"\1\2\3\4 = \2(),\5;"),
    # Any declaration line not containing an initializer goes away.
    (r"\n[ \t]*(?:%(type)s|%(class)s)[^=;]*;", ""),
    ),
    (
    # Group 4: At this point all declarations left have initializers.
    # Replace commas in declaration lines with semis, otherwise Python will
    # barf later because it thinks that, e.g., a=4, b=5  is an attempt to
    # assign a constant to a tuple.
    # FIXME: This will fail messily on GCC structure intializers.
    (r"(\n[ \t]*(?:%(type)s|%(class)s).*),(.*);", r"\1;\2"),
    ),
    (
    # Group 5: Now rip out all remaining base type information.
    # This will strip remaining type declarators out of formal parameter lists.
    # It will also remove types from the beginning of declaration lines.
    # Won't nuke casts because it looks for at least one following whitespace.
    (r"(?:%(type)s|%(class)s)[\s;]\s*", ""),
    ),
)

# These get applied once within regions, before type info has been stripped
pre_transformations = (
    # We used to do function header translation here.   We leave
   # this in place because we'll probably need to do things here again.
    )

# These get applied once within regions, after type info has been stripped
post_transformations = (
    # some consequences of having translated function headers
    (r"\(void\):\n", r"():\n"),
    (r"def(.*):\n\Z", r"def\1:\n    "),	# indent comment on line after def
    # externs can just disappear -- this may discard a following comment
    (r"extern[^;]+;.*\n", r""),
    # macros
    (r"#define\s+(%(id)s)\s+(.*)", r"\1\t= \2"),
    (r"#define\s+(%(id)s)\(([^)]*)\)\s+(.*\))", r"def \1(\2):\treturn \3"),
    (r"#define\s+(%(id)s)\(([^)]*)\)\s+([^(].*)", r"def \1(\2):\t\3"),
    # control structure
    (r"\bif *\((.*)\)", r"if \1:"),
    (r"\bwhile *\((.*)\)", r"while \1:"), 
    (r"\bwhile 1:", r"while True:"),
    (r"\bfor \(;;\)\s*{", r"while True:"),
    (r"\bfor \((%(id)s) *= *0; *\1 *<= *([^;]+); *\1\+\+\)",
     					r"for \1 in range(\2+1):"),
    (r"\bfor \((%(id)s) *= *(\w+); *\1 *<= *([^;]+); *\1\+\+\)",
     					r"for \1 in range(\2, \3+1):"),
    (r"\bfor \((%(id)s) *= *0; *\1 *< *([^;]+); *\1\+\+\)",
     					r"for \1 in range(\2):"),
    (r"\bfor \((%(id)s) *= *(\w+); *\1 *< *([^;]+); *\1\+\+\)",
     					r"for \1 in range(\2, \3):"),
    (r"else if", r"elif"),
    (r"else *{", r"else"),
    (r"(?<!#)else", r"else:"),
    (r"switch *\(", r"switch "),	# Not Python, but less ugly
    # constants
    (r"\btrue\b", r"True"),	# C99
    (r"\bfalse\b", r"False"),	# C99
    (r"\bTRUE\b", r"True"),	# pre-C99
    (r"\bFALSE\b", r"False"),	# pre-C99
    # expression operations
    (r" *\&\& *", r" and "),
    (r" *\|\| *", r" or "),
    (r"-\>", "."),
    (r"!(?!=) *", "not "),
    (r"(and|or) *\n", r"\1 \\\n"),
    # most common uses of address operator
    (r"return *&", "return "),
    (r"= *&", "= "),
    # increment and decrement statements
    (r"(%(id)s)\+\+([;\n])", r"\1 += 1\2"),
    (r"(%(id)s)--([;\n])", r"\1 -= 1\2"),
    (r"\+\+(%(id)s)([;\n])", r"\1 += 1\2"),
    (r"--(%(id)s)([;\n])", r"\1 -= 1\2"),
    # no-op voids
    (r"\n[ \t]*\(void\)", r"\n"),  
    # C functions that turn into Python builtins
    (r"\batoi\(", r"int("),
    (r"\batof\(", r"float("),
    (r"\batol\(", r"long("),
    (r"\bfclose\((%(id)s)\)", r"\1.close()"),
    (r"\bfopen\(", r"open("),
    (r"\bfprintf\((%(id)s), *", r"\1.write("),
    (r"\bstrlen\(", r"len("),
    (r"\bstrcmp\((%(exp)s), *(%(exp)s)\) *== *0", r"\1 == \2"),
    (r"\bstrcmp\((%(exp)s), *(%(exp)s)\) *!= *0", r"\1 != \2"),
    (r"\bstrcpy\((%(exp)s), *(%(exp)s)\)", r"\1 = \2"),
    # Python string library
    (r"\btoupper\(", r"string.upper("),
    (r"\btolower\(", r"string.lower("),
    # Python os library
    (r"\b(access|chdir|fchdir|chroot|chmod|chown|lchown|getcwd|lstat|mkfifo|mknod|mkdir|pathconf|rmdir|symlink|unlink)\(", r"os.\1("),
    (r"\b(F_OK|R_OK|W_OK|X_OK|S_ISUID|S+ISGID|S_ENFMT|S_ISVTX|S_IREAD|S_IWRITE|S_IEXEC|S_IRWXU|S_IRUSR|S_IXUSR|S_IRWXG|S_IRGRP|S_IWGRP|S_IXGRP|S_IRWXO|S_IROTH|S_IWOTH|S_IXOTH)\b", r"os.\1"),
    # Python time library
    (r"\btime\(NULL\)", r"time.time()"),
    # Python math library
    (r"\b(acos|asin|atan|atan2|ceil|cos|cosh|exp|fabs|floor|fmod|ldexp|log10|log|pow|sinh|sin|sqrt|tan|tanh)\(", r"math.\1("),
    # well-known includes
    (r"#include \<string.h\>\n", ""),
    (r"#include \<stdlib.h\>\n", ""),
    (r"#include \<stdbool.h\>\n", ""),
    (r"#include \<stdio.h\>\n", "import sys\n"),
    (r"#include \<math.h\>\n", r"import math\n"),
    (r"#include \<time.h\>\n", r"import time\n"),
    (r"#include \<regex.h\>\n", r"import re\n"),
    (r"#include \<curses.h\>\n", r"import curses\n"),
)

final_transformations = (
    # block delimiters -- do these as late as possible, they're useful
    (r";(%(eol)s)", r"\1"),
    (r"\n[ \t]*}%(eol)s", r""),
    (r"(?<!=\n)\n{\n", "\n"),	# Start-of-line brace that's not an initializer
    )

def single_apply(transforms, text):
    "Apply specified set of transformations once."
    for (fro, to) in transforms:
        oldtext = text
        # Prepending \n then stripping it means that \n can reliably
        # be used to recognize start of line.
        text = re.sub(fro % shorthands, to, "\n" + oldtext)[1:]
        if debug >= 2 and text != oldtext:
            print "%s transforms '%s' to '%s'" % ((fro, to), oldtext, text)
    return text

def repeat_apply(transforms, text):
    "Repeatedly apply specified transformations to text until it's stable."
    while True:
        transformed = single_apply(transforms, text)
        if transformed != text:
            text = transformed
        else:
            break
    return text

def ctopy(input):
    "Transform C to Python."
    if debug >= 2:
        print "Gathering hints"
    hints = re.finditer(r"\$ctopy (.*)", input)
    for hint in hints:
        process_hint(hint.group(1))
    if debug >= 2:
        print "Processing inline enums"
    global stringify
    enums = re.finditer(r"enum[ \t]*{(.*)} (%(id)s)" % shorthands, input)
    for instance in enums:
        stringify += instance.group(1).replace(" ", "").split(",")
        input = input[:instance.start(0)] + input[instance.start(2):]
    if debug:
        print "Pre-transformations begin"
    input = repeat_apply(file_transformations, input)
    if debug >= 2:
        print "After pre-transformations: %s" % `code`
    if debug:
        print "Region analysis begins"
    boundaries = [0]
    state = "text"
    for i in range(len(input)):
        if state == "text":
            if input[i] == '"' and (i == 0 or input[i-1] != '\\'):
                if debug >= 2:
                    print "String literal starts at %d" % i
                boundaries.append(i)
                state = "stringliteral"
            elif input[i:i+2] == "/*":
                if debug >= 2:
                    print "Closed comment starts at %d" % (i-1)
                boundaries.append(i)
                state = "closedcomment"
            elif input[i:i+2] == "//":
                if debug >= 2:
                    print "Open comment starts at %d" % i
                boundaries.append(i)
                state = "opencomment"
            elif input[i:].startswith("typedef enum {") or input[i:].startswith("enum {"):
                if debug >= 2:
                    print "enumeration starts at %d" % i
                if input[i-2:i+1] != 'f e':
                    boundaries.append(i)
                boundaries.append(i + input[i:].find("enum") + 5)
            elif input[i:].startswith("\n}"):
                if debug >= 2:
                    print "start-of-line brace at %d" % i
                boundaries.append(i)
                boundaries.append(i+2)
        elif state == "stringliteral":
            if input[i] == '"' and (i == 0 or input[i-1] != '\\'):
                if debug >= 2:
                    print "String ends at %d" % i
                boundaries.append(i+1)
                state = "text"
        elif state == "closedcomment":
            if input[i:i+2] == "*/":
                if debug >= 2:
                    print "closed comment ends at %d" % (i+1)
                boundaries.append(i+2)
                state = "text"                
        elif state == "opencomment":
            if input[i] == "\n":
                if debug >= 2:
                    print "Open comment ends at %d" % (i+1)
                boundaries.append(i+1)
                state = "text"
    boundaries.append(len(input))
    if debug >= 2:
        print "Boundaries:", boundaries
    regions = []
    for i in range(len(boundaries)-1):
        regions.append(input[boundaries[i]:boundaries[i+1]])
    regions = filter(lambda x: x != '', regions)
    if debug:
        print "Regexp transformation begins"
    if debug:
        import pprint
        pp = pprint.PrettyPrinter(indent=4)
        print "Regions:"
        pp.pprint(regions)
    if debug >= 2:
        print "Processing printf-like functions"
    for (i, here) in enumerate(regions):
        if regions[i][0] != '"' or not "%" in here:
            continue
        else:
            for func in printflike:
                if re.search(r"\b%s\([^;]*\Z" % func, regions[i]):
                    break
                else:
                    continue	# Didn't find printf-like function
        regions[i+1] = " % (" + regions[i+1][1:].lstrip()
        j = 3
        parenlevel = 0
        while j < len(regions[i+1]):
            if regions[i+1][j] == "(":
                parenlevel += 1
            if regions[i+1][j] == ")":
                parenlevel -= 1
            if parenlevel == 0:
                regions[i+1] = regions[i+1][:j] + ")" + regions[i+1][j:]
                break
            j += 1
    try:
        for i in range(len(regions)):
            if regions[i][:2] == "/*":
                if regions[i].count("\n") <= 1:		# winged comment
                    regions[i] = "#" + regions[i][2:-2]
                elif re.search("/\*+\n", regions[i]):	# boxed comment
                    regions[i] = re.sub(r"\n([ \t]*) \* ?", r"\n\1",regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)\*", r"\n\1", regions[i])
                    regions[i] = re.sub(r"^([ \t]*)/\*+\n", r"\1#\n", regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)\**/", r"\n\1", regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)(?!#)", r"\n\1# ", regions[i])
                else:
                    regions[i] = regions[i].replace("/*", "#")
                    regions[i] = regions[i].replace("\n*/", "\n#")
                    regions[i] = regions[i].replace("*/", "")
                    regions[i] = regions[i].replace("\n *", "\n")
                    regions[i] = regions[i].replace("\n", "\n#")
            elif regions[i][:2] == "//":
                regions[i] = "#" + regions[i][2:]
            elif regions[i][0] != '"':
                if debug >= 2:
                    print "Doing pre transformations"
                regions[i] = single_apply(pre_transformations, regions[i])
                if debug >= 2:
                    print "Doing repeated transformations"
                for (j, hack) in enumerate(repeat_transformations):
                    if debug >= 2:
                        print "Repeat transformations group %d" % (j+1)
                    regions[i] = repeat_apply(hack, regions[i])
                if debug >= 2:
                    print "Doing post transformations"
                regions[i] = single_apply(post_transformations, regions[i])
                for str in stringify:
                    regions[i] = re.sub(r"\b" + str + r"\b",
                                        '"' + str + '"', regions[i])
    except IndexError:
        sys.stderr.write("ctopy: pathological string literal at %d.\n" % boundaries[i])
        raise SystemExit, 1
    if debug:
        "Enumeration processing"
    state = "plain"
    for (i, region) in enumerate(regions):
        # first compute a parse state
        if region.startswith("typedef enum"):
            state = "typedef"
        elif region.startswith("enum"):
            state = "enum"
        elif region == "\n}":
            if state in ("typedef", "enum"):
                regions[i] = ''
                state = "plain"
        # now do something useful with it
        if debug >= 3:
            print "Enumeration processing: state = %s, region = %s" % (state, `regions[i]`)
        if state in ("enum", "typedef"):
            if regions[i] == "enum ":
                m = re.match("(%(id)s) {" % shorthands, regions[i+1])
                if m:
                    shorthands['type'] += "|" + m.group(1)
                    regions[i] = '# From enumerated type \'%s\'\n' % m.group(1)
                    regions[i+1] = regions[i+1][m.end(0)+1:]
                else: 
                    regions[i] = '# From anonymous enumerated type\n'
            elif regions[i] == "typedef enum ":
                m = re.match("\s* (%(id)s)\s*;?" % shorthands, regions[i+3])
                if m:
                    shorthands['type'] += "|" + m.group(1)
                    regions[i] = '# From enumerated type \'%s\'\n' % m.group(1)
                    regions[i+3] = regions[i+3][:m.start(0)] + "\n\n"
                else: 
                    regions[i] = '# From anonymous typedefed enum (?!)\n'
            else:
                regions[i] = re.sub(",\s*", "\n", regions[i])
                val = 0
                txt = regions[i].split("\n")
                for j in range(len(txt)):
                    if txt[j] == '' or txt[j].startswith("{"):
                        pass
                    elif '=' not in txt[j]:
                        txt[j] += " = %d" % val
                        val += 1
                regions[i] = "\n".join(txt)
    if debug:
        "Final transformations begin"
    regions = map(lambda r: repeat_apply(final_transformations, r),regions)
    if debug:
        print "Import checks begin"
    importlist = []
    try:
        for i in range(len(regions)):
            if len(regions[i]) and regions[i][0]!='"' and regions[i][0]!="#":
                for library in ("math", "os", "string", "time"):
                    if re.search(r"\b" + library + r"\.", regions[i]):
                        if library not in importlist:
                            importlist.append(library)
    except IndexError:
        sys.stderr.write("ctopy: internal error on region %d (%s).\n" % (i, regions[i]))
    text = "".join(regions)
    importlist = filter(lambda x: ("import %s" % x).find(text) > -1, importlist)
    if importlist:
        importlist = "import " + ",".join(importlist) + "\n"
        text = importlist + text
    # Emit what we got.  Preserve imports in case this is a .h file 
    return text

def process_hint(line):
    "Process a translation-hints line."
    if line[0] == "#":
        pass
    else:
        if debug >= 2:
            print "Hint: %s" % `line`
        (cmd, tok) = line.split()
        if cmd == "stringify":
            stringify.append(tok)
        elif cmd == "type":
            shorthands["type"] += r"|\b" + tok + r"\b" 
        elif cmd == "class":
            shorthands["class"] += r"|\b" + tok + r"\b"
        elif cmd == "printflike":
            printflike.append(tok)

if __name__ == "__main__":
    import getopt
    (options, arguments) = getopt.getopt(sys.argv[1:], "c:h:ds:t:")
    debug = 0;
    for (switch, val) in options:
	if (switch == '-c'):
            shorthands["class"] += r"|\b" + val + r"\b"
	elif (switch == '-d'):
	    debug += 1
	elif (switch == '-h'):
            for line in open(filename):
                process_hint(line)
	elif (switch == '-s'):
            stringify.append(val)
	elif (switch == '-t'):
            shorthands["type"] += r"|\b" + val + r"\b" 

    code = sys.stdin.read()
    if debug >= 2:
        print "Input is: %s" % `code`
    text = ctopy(code)
    if debug:
        print "Output:"
    sys.stdout.write(text)
