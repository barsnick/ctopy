#!/usr/bin/env python
"""
ctopy -- a quick and dirty C-to-Python translator

Relies on the fact that C and Python have fundamentally similar
expression syntax and control structures, and C is normally indented
in a way that indicates its block structure.  The only parts of
expressions that don't nap over without change are ?: and comma
expressions.

Limitations:
    * Requires source to be syntactically valid,
    * Strange indentation (not one of the standard styles) will confuse it.
    * Translates simples kinds of for-loops with a straight increment of
      a loop variable, but not the more complex ones. 
    * Doesn't even attempt to translate switch/case or do/while.
    * Doesn't attempt to translate ternary operator.
    * C comma expressions will spuriously turn into Python tuuple constructors,
    * We don't translate frexp and modf because their call conventions differ
      between Python and C, so we want them to throw an error.
"""
import sys, re

shorthands = {
    'id' : r"[a-zA-Z_][a-zA-Z0-9._]*",
    'exp' : r"[a-zA-Z0-9._\-+\*/]+",
    'type' : r"\bvoid\b|\bint\b|\bbool\b|\bchar\b|\bshort\b|\bdouble\b|\blong\b|\bfloat\b|\btime_t\b|\bFILE\b",
    'cls' : "\b__dummyclass__\b",
}

# These have to be applied to the entire file without breaking it into regions
file_transformations = (
    # Simple initializers to tuples
    (r"(?:static)?\s+(?:%(type)s)\s+(%(id)s)\[[a-zA-Z0-9._]*]\s*=\s*{([^}]+)}",
     r"\1 = (\2)"),
    )

# These need to be applied repeatedly within regions.
# They rely on semicolons as statatement end markers.
repeat_transformations = (
    (
    # What we're doing here is stripping out prefix, suffix, and wrapper
    # parts of declarations in order to reduce everything to base type
    # followed by whitespace followed by id.  This is significant for
    # simplifying both function formal parameter lists and variable
    # declaration lines.  We'll get rid of the remaining type stuff
    # in a later pass.
    (r"(%(type)s|%(cls)s)\s*\*", r"\1"),	# Pointer type decls
    (r"(%(type)s|%(cls)s)\s*\((%(id)s)\)\(\)", r"\1 \2"),	# Function pointer wrappers
    (r"(%(type)s|%(cls)s)\s*(%(id)s)\[\]", r"\1 \2"),	# Array declarators
    ),
    (
    # What we're doing here is trying to get rid of variable
    # declarations that don't have initializer parts.
    # Bare ids just after the type and before a comma or semi go away.
    (r"(\n[ \t]*(?:%(type)s))(\s*%(id)s)([;,])", r"\1\3"),
    # Bare ids after class names and before comma or semi get an initializer.
    (r"(\n[ \t]*)(%(cls)s)(\s*%(id)s)([;,])", r"\1\2\3 = \2()\4"),
    # Bare types between a comma and a trailing semicolon go away.
    (r"(\n[ \t]*)((?:%(type)s).*)(,\s*%(id)s\s*);", r"\1\2;"),
    # But bare classes between comma and semicolon get a following initializer 
    (r"(\n[ \t]*)(%(cls)s)(.*,\s)*(%(id)s)(\s*;)", r"\1\2\3\4 = \2()\5"),
    # Bare ids between commas in a declaration line go away.
    (r"(\n[ \t]*(?:%(type)s)\s+.*)(,\s*%(id)s),(.*);", r"\1\3"),
    # But bare class names between commas get an initializer
    (r"(\n[ \t]*)(%(cls)s)(\s+.*,)(\s*%(id)s),(.*);", r"\1\2\3\4 = \2(),\5"),
    # Any declaration line not containing an initializer goes away.
    (r"\n[ \t]*(?:%(type)s|%(cls)s)[^=;]*;", ""),
    ),
    (
    # At this point in the game all declarations left have initializers.
    # Replace commas in declaration lines with semis, otherwise Python will
    # barf later because it thinks that, e.g., a=4, b=5  is an attempt to
    # assign a constant to a tuple.
    # FIXME: This will fail messily on GCC structure intializers.
    (r"(\n[ \t]*(?:%(type)s|%(cls)s).*),(.*);", r"\1;\2"),
    ),
    (
    # Now rip out all remaining base type information.
    # This will strip remaining type declarators out of formal parameter lists.
    # It will also remove types from the beginning of declaration lines.
    # Won't nuke casts because it looks for at least one following whitespace.
    (r"(?:%(type)s|%(cls)s)[\s;]\s*", ""),
    ),
)

# These get applied once within regions, before type info has been stripped
pre_transformations = (
    # function headers
    (r"\n(?:static\s+)?(?:%(type)s) +(.*\)) *\n", r"\ndef \1:\n"),
    (r"\(void\):\n", r"():\n"),
    (r"def(.*):\n\Z", r"def\1:\n    "),	# indent comment on line after def
    )

# These get applied once within regions, after type info has been stripped
post_transformations = (
    # externs can just disappear -- this may discard a following comment
    (r"extern[^;]+;.*\n", r""),
    # macros
    (r"#define\s+(%(id)s)\s+(.*)", r"\1\t= \2"),
    (r"#define\s+(%(id)s)\(([^)]*)\)\s+(.*\))", r"def \1(\2):\treturn \3"),
    (r"#define\s+(%(id)s)\(([^)]*)\)\s+([^(].*)", r"def \1(\2):\t\3"),
    # control structure
    (r"if *\(", r"if "),
    (r"while *\(", r"while "), 
    (r"while 1:", r"while True"),
    (r"for \(;;\)\s*{", r"while True"),
    (r"for \((%(id)s) *= *0; *\1 *<= *([^;]+); *\1\+\+\)",
     					r"for \1 in range(\2+1))"),
    (r"for \((%(id)s) *= *(\d+); *\1 *<= *([^;]+); *\1\+\+\)",
     					r"for \1 in range(\2, \3+1))"),
    (r"for \((%(id)s) *= *0; *\1 *< *([^;]+); *\1\+\+\)",
     					r"for \1 in range(\2))"),
    (r"for \((%(id)s) *= *(\d+); *\1 *< *([^;]+); *\1\+\+\)",
     					r"for \1 in range(\2, \3))"),
    (r"\)\s*{", r":"),
    (r"(?<!\()\) *\n([ \t]+)", r":\n\1"),	# ) not followed by ; but by indent
    (r"else if", r"elif"),
    (r"else *{", r"else"),
    (r"(?<!#)else", r"else:"),
    (r"switch *\(", r"switch "),	# Not Python, but less ugly
    # constants
    (r"\btrue\b", r"True"),	# C99
    (r"\bfalse\b", r"False"),	# C99
    (r"\bTRUE\b", r"True"),	# pre-C99
    (r"\bFALSE\b", r"False"),	# pre-C99
    # expression operations
    (r" *\&\& *", r" and "),
    (r" *\|\| *", r" or "),
    (r"-\>", "."),
    (r"!(?!=) *", "not "),
    (r"(and|or) *\n", r"\1 \\\n"),
    # increment and decrement statements
    (r"(%(id)s)\+\+([;\n])", r"\1 += 1\2"),
    (r"(%(id)s)--([;\n])", r"\1 -= 1\2"),
    (r"\+\+(%(id)s)([;\n])", r"\1 += 1\2"),
    (r"--(%(id)s)([;\n])", r"\1 -= 1\2"),
    # no-op voids
    (r"\n[ \t]*\(void\)", r"\n"),  
    # C functions that turn into Python builtins
    (r"\batoi\(", r"int("),
    (r"\batof\(", r"float("),
    (r"\batol\(", r"long("),
    (r"\bfclose\((%(id)s)\)", r"\1.close()"),
    (r"\bfopen\(", r"open("),
    (r"\bfprintf\((%(id)s), *", r"\1.write("),
    (r"\bstrlen\(", r"len("),
    (r"\bstrcmp\((%(exp)s), *(%(exp)s)\) *== *0", r"\1 == \2"),
    (r"\bstrcmp\((%(exp)s), *(%(exp)s)\) *!= *0", r"\1 != \2"),
    (r"\bstrcpy\((%(exp)s), *(%(exp)s)\)", r"\1 = \2"),
    # Python string library
    (r"\btoupper\(", r"string.upper("),
    (r"\btolower\(", r"string.lower("),
    # Python os library
    (r"\b(access|chdir|fchdir|chroot|chmod|chown|lchown|getcwd|lstat|mkfifo|mknod|mkdir|pathconf|rmdir|symlink|unlink)\(", r"os.\1("),
    (r"\b(F_OK|R_OK|W_OK|X_OK|S_ISUID|S+ISGID|S_ENFMT|S_ISVTX|S_IREAD|S_IWRITE|S_IEXEC|S_IRWXU|S_IRUSR|S_IXUSR|S_IRWXG|S_IRGRP|S_IWGRP|S_IXGRP|S_IRWXO|S_IROTH|S_IWOTH|S_IXOTH)\b", r"os.\1"),
    # Python time library
    (r"\btime\(NULL\)", r"time.time()"),
    # Python math library
    (r"\b(acos|asin|atan|atan2|ceil|cos|cosh|exp|fabs|floor|fmod|ldexp|log10|log|pow|sinh|sin|sqrt|tan|tanh)\(", r"math.\1("),
    # well-known includes
    (r"#include \<string.h\>\n", ""),
    (r"#include \<stdlib.h\>\n", ""),
    (r"#include \<stdbool.h\>\n", ""),
    (r"#include \<stdio.h\>\n", "import sys\n"),
    (r"#include \<math.h\>\n", r"import math\n"),
    (r"#include \<time.h\>\n", r"import time\n"),
    (r"#include \<regex.h\>\n", r"import re\n"),
    (r"#include \<curses.h\>\n", r"import curses\n"),
    # block delimiters -- do these as late as possible, they're useful
    (r";\n", r"\n"),
    (r"\n[ \t]*}\n", r"\n"),
    (r"(?<!=\n)\n{\n", "\n"),	# Start-of-line brace that's not an initializer
    )

def single_apply(transforms, text):
    "Apply specified set of transformations once."
    for (fro, to) in transforms:
        oldtext = text
        # Prepending \n then stripping it means that \n can reliably
        # be used to recognize start of line.
        text = re.sub(fro % shorthands, to, "\n" + oldtext)[1:]
        if debug >= 2 and text != oldtext:
            print "%s transforms %s to %s: groups" % ((fro, to), oldtext, text)
    return text

def repeat_apply(transforms, text):
    "Repeatedly apply specified transformations to text until it's stable."
    while True:
        transformed = single_apply(transforms, text)
        if transformed != text:
            text = transformed
        else:
            break
    return text

def ctopy(input):
    "Transform C to Python."
    if debug:
        print "Pre-transformations begin"
    input = repeat_apply(file_transformations, input)
    if debug >= 2:
        print "After pre-transformations: %s" % `code`
    if debug:
        print "Region analysis begins"
    boundaries = [0]
    state = "text"
    for i in range(len(input)):
        if state == "text":
            if input[i] == '"' and (i == 0 or input[i-1] != '\\'):
                if debug >= 2:
                    print "String literal starts at %d" % i
                boundaries.append(i)
                state = "stringliteral"
            elif input[i:i+2] == "/*":
                if debug >= 2:
                    print "Closed comment starts at %d" % (i-1)
                boundaries.append(i)
                state = "closedcomment"
            elif input[i:i+2] == "//":
                if debug >= 2:
                    print "Open comment starts at %d" % i
                boundaries.append(i)
                state = "opencomment"
        elif state == "stringliteral":
            if input[i] == '"' and (i == 0 or input[i-1] != '\\'):
                if debug >= 2:
                    print "String ends at %d" % i
                boundaries.append(i+1)
                state = "text"
        elif state == "closedcomment":
            if input[i:i+2] == "*/":
                if debug >= 2:
                    print "closed comment ends at %d" % (i+1)
                boundaries.append(i+2)
                state = "text"                
        elif state == "opencomment":
            if input[i] == "\n":
                if debug >= 2:
                    print "Open comment ends at %d" % (i+1)
                boundaries.append(i+1)
                state = "text"
    boundaries.append(len(input))
    if debug >= 2:
        print "Boundaries:", boundaries
    if debug:
        print "Regexp transformation begins"
    regions = []
    for i in range(len(boundaries)-1):
        regions.append(input[boundaries[i]:boundaries[i+1]])
    regions = filter(lambda x: x != '', regions)
    if debug:
        import pprint
        pp = pprint.PrettyPrinter(indent=4)
        print "Regions:"
        pp.pprint(regions)
    try:
        for i in range(len(regions)):
            if regions[i][:2] == "/*":
                if regions[i].count("\n") <= 1:		# winged comment
                    regions[i] = "#" + regions[i][2:-2]
                elif re.search("/\*+\n", regions[i]):	# boxed comment
                    regions[i] = re.sub(r"\n([ \t]*) \* ?", r"\n\1",regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)\*", r"\n\1", regions[i])
                    regions[i] = re.sub(r"^([ \t]*)/\*+\n", r"\1#\n", regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)\**/", r"\n\1", regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)(?!#)", r"\n\1# ", regions[i])
                else:
                    regions[i] = regions[i].replace("/*", "#")
                    regions[i] = regions[i].replace("\n*/", "\n#")
                    regions[i] = regions[i].replace("*/", "")
                    regions[i] = regions[i].replace("\n *", "\n")
                    regions[i] = regions[i].replace("\n", "\n#")
            elif regions[i][:2] == "//":
                regions[i] = "#" + regions[i][2:]
            elif regions[i][0] != '"':
                if debug >= 2:
                    print "Doing repeated transformations"
                regions[i] = single_apply(pre_transformations, regions[i])
                for hack in repeat_transformations:
                    regions[i] = repeat_apply(hack, regions[i])
                regions[i] = single_apply(post_transformations, regions[i])
    except IndexError:
        sys.stderr.write("ctopy: pathological string literal at %d.\n" % boundaries[i])
        raise SystemExit, 1
    if debug:
        print "Import checks begin"
    importlist = []
    try:
        for i in range(len(regions)):
            if len(regions[i]) and regions[i][0]!='"' and regions[i][0]!="#":
                for library in ("math", "os", "string", "time"):
                    if re.search(r"\b" + library + r"\.", regions[i]):
                        if library not in importlist:
                            importlist.append(library)
    except IndexError:
        sys.stderr.write("ctopy: internal error on region %d (%s).\n" % (i, regions[i]))
    text = "".join(regions)
    importlist = filter(lambda x: ("import %s" % x).find(text) > -1, importlist)
    if importlist:
        importlist = "import " + ",".join(importlist) + "\n"
        text = importlist + text
    # Emit what we got.  Preserve imports in case this is a .h file 
    return text

if __name__ == "__main__":
    import getopt
    (options, arguments) = getopt.getopt(sys.argv[1:], "c:d")
    debug = 0;
    classes = ["__dummyclass__"]
    for (switch, val) in options:
	if (switch == '-c'):
	    classes.append(val)
            shorthands["cls"] = "|".join(filter(lambda x: r"\b"+x+r"\b", classes))
	elif (switch == '-d'):
	    debug += 1

    code = sys.stdin.read()
    if debug >= 2:
        print "Input is: %s" % `code`
    text = ctopy(code)
    sys.stdout.write(text)
