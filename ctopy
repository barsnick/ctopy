#!/usr/bin/env python
"""
ctopy -- a quick and dirty C-to-Python translator

FIXME: Python library bindings are as of 2.6a0.
FIXME: The curses mapping is quite incomplete.
FIXME: libraries not yet mapped: curses.panel, dbm, md5.
FIXME: Python library scan is only complete up to logging.
"""
import sys, re

stringify = []

printflike = ["printf", "sprintf", "vfprintf"]

shorthands = {
    'id' : r"[a-zA-Z_][a-zA-Z0-9._]*",
    'exp' : r"[a-zA-Z0-9._\-+\*/]+",
    'type' : r"\bvoid\b|\bint\b|\bbool\b|\bchar\b|\bshort\b|\bdouble\b|\blong\b|\bfloat\b|\btime_t\b|\bFILE\b|bWINDOW\b",
    'class' : "\b__dummyclass__\b",
    'ind' : "(\n[ \t]*)",		# Whitespace at start of line
    'eol' : "[ \t]*(?=\n|\Z)",		# Whitespace to end of line or comment
}

# C functions and constants to be mapped into Python standard library bindings.
# This list is explicit because sometimes there are slight name changes...
# and because explicit is better than implicit.
funmappings = (
    # Python atexit library
    ("atexit", "atexit.register"),
    # Python crypt library
    ("crypt", "crypt.crypt"),
    # Python curses bindings emulate the C API rather exactly.  These are
    # the module functions.
    ("baudrate", "curses.baudrate"),
    ("beep", "curses.beep"),
    ("can_change_color", "curses.can_change_color"),
    ("cbreak", "curses.cbreak"),
    ("color_content", "curses.color_content"),
    ("color_pair", "curses.color_pair"),
    ("curs_set", "curses.curs_set"),
    ("def_prog_mode", "curses.def_prog_mode"),
    ("def_shell_mode", "curses.def_shell_mode"),
    ("delay_output", "curses.delay_output"),
    ("doupdate", "curses.doupdate"),
    ("echo", "curses.echo"),
    ("endwin", "curses.endwin"),
    ("erasechar", "curses.erasechar"),
    ("filter", "curses.filter"),
    ("flash", "curses.flash"),
    ("flushinp", "curses.flushinp"),
    ("getmouse", "curses.getmouse"),
    ("getsyx", "curses.getsyx"),		# Calling convention is different
    ("getwin", "curses.getwin"),
    ("has_colors", "curses.has_colors"),
    ("has_ic", "curses.has_ic"),
    ("has_il", "curses.has_il"),
    ("has_key", "curses.has_key"),
    ("init_color", "curses.init_color"),
    ("init_pair", "curses.init_pair"),
    ("initscr", "curses.initscr"),	# Must make this a global
    ("isendwin", "curses.isendwin"),
    ("keyname", "curses.keyname"),
    ("killchar", "curses.killchar"),
    ("longname", "curses.longname"),
    ("meta", "curses.meta"),
    ("mouseinterval", "curses.mouseinterval"),
    ("mousemask", "curses.mousemask"),
    ("napms", "curses.napms"),
    ("newpad", "curses.newpad"),
    ("newwin", "curses.newwin"),
    ("nl", "curses.nl"),
    ("nocbreak", "curses.nocbreak"),
    ("noecho", "curses.noecho"),
    ("nonl", "curses.nonl"),
    ("noqiflush", "curses.noqiflush"),
    ("noraw", "curses.noraw"),
    ("pair_content", "curses.pair_content"),
    ("pair_number", "curses.pair_number"),
    ("putp", "curses.putp"),
    ("qiflush", "curses.qiflush"),
    ("raw", "curses.raw"),
    ("reset_prog_mode", "curses.reset_prog_mode"),
    ("reset_shell_mode", "curses.reset_shell_mode"),
    ("setsyx", "curses.setsyx"),
    ("setupterm", "curses.setupterm"),
    ("start_color", "curses.start_color"),
    ("termattrs", "curses.termattrs"),
    ("termname", "curses.termname"),
    ("tigetflag", "curses.tigetflag"),
    ("tigetnum", "curses.tigetnum"),
    ("tigetstr", "curses.tigetstr"),
    ("tparm", "curses.tparm"),
    ("typeahead", "curses.typeahead"),
    ("unctrl", "curses.unctrl"),
    ("ungetch", "curses.ungetch"),
    ("ungetmouse", "curses.ungetmouse"),
    ("use_env", "curses.use_env"),
    ("A_ATTRIBUTES", "curses.A_ATTRIBUTES"),
    ("A_NORMAL", "curses.A_NORMAL"),
    ("A_STANDOUT", "curses.A_STANDOUT"),
    ("A_UNDERLINE", "curses.A_UNDERLINE"),
    ("A_REVERSE", "curses.A_REVERSE"),
    ("A_BLINK", "curses.A_BLINK"),
    ("A_DIM", "curses.A_DIM"),
    ("A_BOLDW", "curses.A_BOLDW"),
    ("A_ALTCHARSET", "curses.A_ALTCHARSET"),
    ("A_INVIS", "curses.A_INVIS"),
    ("A_PROTECT", "curses.A_PROTECT"),
    ("A_HORIZONTAL", "curses.A_HORIZONTAL"),
    ("A_LEFT", "curses.A_LEFT"),
    ("A_LOW", "curses.A_LOW"),
    ("A_RIGHT", "curses.A_RIGHT"),
    ("A_TOP", "curses.A_TOP"),
    ("A_VERTICAL", "curses.A_VERTICAL"),
    ("OLOR_BLACK", "curses.OLOR_BLACK"),
    ("OLOR_RED", "curses.OLOR_RED"),
    ("OLOR_GREEN", "curses.OLOR_GREEN"),
    ("OLOR_YELLOW", "curses.OLOR_YELLOW"),
    ("OLOR_BLUE", "curses.OLOR_BLUE"),
    ("OLOR_MAGENTA", "curses.OLOR_MAGENTA"),
    ("OLOR_CYAN", "curses.OLOR_CYAN"),
    ("OLOR_WHITE", "curses.OLOR_WHITE"),
    ("ACS_ULCORNER", "curses.ACS_ULCORNER"),
    ("ACS_LLCORNER", "curses.ACS_LLCORNER"),
    ("ACS_URCORNER", "curses.ACS_URCORNER"),
    ("ACS_LRCORNER", "curses.ACS_LRCORNER"),
    ("ACS_LTEE", "curses.ACS_LTEE"),
    ("ACS_RTEE", "curses.ACS_RTEE"),
    ("ACS_BTEE", "curses.ACS_BTEE"),
    ("ACS_TTEE", "curses.ACS_TTEE"),
    ("ACS_HLINE", "curses.ACS_HLINE"),
    ("ACS_VLINE", "curses.ACS_VLINE"),
    ("ACS_PLUS", "curses.ACS_PLUS"),
    ("ACS_S1", "curses.ACS_S1"),
    ("ACS_S9", "curses.ACS_S9"),
    ("ACS_DIAMOND", "curses.ACS_DIAMOND"),
    ("ACS_CKBOARD", "curses.ACS_CKBOARD"),
    ("ACS_DEGREE", "curses.ACS_DEGREE"),
    ("ACS_PLMINUS", "curses.ACS_PLMINUS"),
    ("ACS_BULLET", "curses.ACS_BULLET"),
    ("ACS_LARROW", "curses.ACS_LARROW"),
    ("ACS_RARROW", "curses.ACS_RARROW"),
    ("ACS_DARROW", "curses.ACS_DARROW"),
    ("ACS_UARROW", "curses.ACS_UARROW"),
    ("ACS_BOARD", "curses.ACS_BOARD"),
    ("ACS_LANTERN", "curses.ACS_LANTERN"),
    ("ACS_BLOCK", "curses.ACS_BLOCK"),
    # Python curses.ascii library
    ("isalnum", "curses.ascii.isalnum"),
    ("isalpha", "curses.ascii.isalpha"),
    ("isascii", "curses.ascii.isascii"),
    ("isblank", "curses.ascii.isblank"),
    ("iscntrl", "curses.ascii.iscntrl"),
    ("isdigit", "curses.ascii.isdigit"),
    ("isgraph", "curses.ascii.isgraph"),
    ("islower", "curses.ascii.islower"),
    ("isprint", "curses.ascii.isprint"),
    ("ispunct", "curses.ascii.ispunct"),
    ("isspace", "curses.ascii.isspace"),
    ("isupper", "curses.ascii.isupper"),
    ("isxdigit", "curses.ascii.isxdigit"),
    ("isctrl", "curses.ascii.isctrl"),
    ("ismeta", "curses.ascii.ismeta"),
    # Python errno library
    ("EPERM", "errno.EPERM"),
    ("ENOENT", "errno.ENOENT"),
    ("ESRCH", "errno.ESRCH"),
    ("EINTR", "errno.EINTR"),
    ("EIO", "errno.EIO"),
    ("ENXIO", "errno.ENXIO"),
    ("E2BIG", "errno.E2BIG"),
    ("ENOEXEC", "errno.ENOEXEC"),
    ("EBADF", "errno.EBADF"),
    ("ECHILD", "errno.ECHILD"),
    ("EAGAIN", "errno.EAGAIN"),
    ("ENOMEM", "errno.ENOMEM"),
    ("EACCES", "errno.EACCES"),
    ("EFAULT", "errno.EFAULT"),
    ("ENOTBLK", "errno.ENOTBLK"),
    ("EBUSY", "errno.EBUSY"),
    ("EEXIST", "errno.EEXIST"),
    ("EXDEV", "errno.EXDEV"),
    ("ENODEV", "errno.ENODEV"),
    ("ENOTDIR", "errno.ENOTDIR"),
    ("EISDIR", "errno.EISDIR"),
    ("EINVAL", "errno.EINVAL"),
    ("ENFILE", "errno.ENFILE"),
    ("EMFILE", "errno.EMFILE"),
    ("ENOTTY", "errno.ENOTTY"),
    ("ETXTBSY", "errno.ETXTBSY"),
    ("EFBIG", "errno.EFBIG"),
    ("ENOSPC", "errno.ENOSPC"),
    ("ESPIPE", "errno.ESPIPE"),
    ("EROFS", "errno.EROFS"),
    ("EMLINK", "errno.EMLINK"),
    ("EPIPE", "errno.EPIPE"),
    ("EDOM", "errno.EDOM"),
    ("ERANGE", "errno.ERANGE"),
    ("EDEADLK", "errno.EDEADLK"),
    ("ENAMETOOLONG", "errno.ENAMETOOLONG"),
    ("ENOLCK", "errno.ENOLCK"),
    ("ENOSYS", "errno.ENOSYS"),
    ("ENOTEMPTY", "errno.ENOTEMPTY"),
    ("ELOOP", "errno.ELOOP"),
    ("EWOULDBLOCK", "errno.EWOULDBLOCK"),
    ("ENOMSG", "errno.ENOMSG"),
    ("EIDRM", "errno.EIDRM"),
    ("ECHRNG", "errno.ECHRNG"),
    ("EL2NSYNC", "errno.EL2NSYNC"),
    ("EL3HLT", "errno.EL3HLT"),
    ("EL3RST", "errno.EL3RST"),
    ("ELNRNG", "errno.ELNRNG"),
    ("EUNATCH", "errno.EUNATCH"),
    ("ENOCSI", "errno.ENOCSI"),
    ("EL2HLT", "errno.EL2HLT"),
    ("EBADE", "errno.EBADE"),
    ("EBADR", "errno.EBADR"),
    ("EXFULL", "errno.EXFULL"),
    ("ENOANO", "errno.ENOANO"),
    ("EBADRQC", "errno.EBADRQC"),
    ("EBADSLT", "errno.EBADSLT"),
    ("EDEADLOCK", "errno.EDEADLOCK"),
    ("EBFONT", "errno.EBFONT"),
    ("ENOSTR", "errno.ENOSTR"),
    ("ENODATA", "errno.ENODATA"),
    ("ETIME", "errno.ETIME"),
    ("ENOSR", "errno.ENOSR"),
    ("ENONET", "errno.ENONET"),
    ("ENOPKG", "errno.ENOPKG"),
    ("EREMOTE", "errno.EREMOTE"),
    ("ENOLINK", "errno.ENOLINK"),
    ("EADV", "errno.EADV"),
    ("ESRMNT", "errno.ESRMNT"),
    ("ECOMM", "errno.ECOMM"),
    ("EPROTO", "errno.EPROTO"),
    ("EMULTIHOP", "errno.EMULTIHOP"),
    ("EDOTDOT", "errno.EDOTDOT"),
    ("EBADMSG", "errno.EBADMSG"),
    ("EOVERFLOW", "errno.EOVERFLOW"),
    ("ENOTUNIQ", "errno.ENOTUNIQ"),
    ("EBADFD", "errno.EBADFD"),
    ("EREMCHG", "errno.EREMCHG"),
    ("ELIBACC", "errno.ELIBACC"),
    ("ELIBBAD", "errno.ELIBBAD"),
    ("ELIBSCN", "errno.ELIBSCN"),
    ("ELIBMAX", "errno.ELIBMAX"),
    ("ELIBEXEC", "errno.ELIBEXEC"),
    ("EILSEQ", "errno.EILSEQ"),
    ("ERESTART", "errno.ERESTART"),
    ("ESTRPIPE", "errno.ESTRPIPE"),
    ("EUSERS", "errno.EUSERS"),
    ("ENOTSOCK", "errno.ENOTSOCK"),
    ("EDESTADDRREQ", "errno.EDESTADDRREQ"),
    ("EMSGSIZE", "errno.EMSGSIZE"),
    ("EPROTOTYPE", "errno.EPROTOTYPE"),
    ("ENOPROTOOPT", "errno.ENOPROTOOPT"),
    ("EPROTONOSUPPORT", "errno.EPROTONOSUPPORT"),
    ("ESOCKTNOSUPPORT", "errno.ESOCKTNOSUPPORT"),
    ("EOPNOTSUPP", "errno.EOPNOTSUPP"),
    ("EPFNOSUPPORT", "errno.EPFNOSUPPORT"),
    ("EAFNOSUPPORT", "errno.EAFNOSUPPORT"),
    ("EADDRINUSE", "errno.EADDRINUSE"),
    ("EADDRNOTAVAIL", "errno.EADDRNOTAVAIL"),
    ("ENETDOWN", "errno.ENETDOWN"),
    ("ENETUNREACH", "errno.ENETUNREACH"),
    ("ENETRESET", "errno.ENETRESET"),
    ("ECONNABORTED", "errno.ECONNABORTED"),
    ("ECONNRESET", "errno.ECONNRESET"),
    ("ENOBUFS", "errno.ENOBUFS"),
    ("EISCONN", "errno.EISCONN"),
    ("ENOTCONN", "errno.ENOTCONN"),
    ("ESHUTDOWN", "errno.ESHUTDOWN"),
    ("ETOOMANYREFS", "errno.ETOOMANYREFS"),
    ("ETIMEDOUT", "errno.ETIMEDOUT"),
    ("ECONNREFUSED", "errno.ECONNREFUSED"),
    ("EHOSTDOWN", "errno.EHOSTDOWN"),
    ("EHOSTUNREACH", "errno.EHOSTUNREACH"),
    ("EALREADY", "errno.EALREADY"),
    ("EINPROGRESS", "errno.EINPROGRESS"),
    ("ESTALE", "errno.ESTALE"),
    ("EUCLEAN", "errno.EUCLEAN"),
    ("ENOTNAM", "errno.ENOTNAM"),
    ("ENAVAIL", "errno.ENAVAIL"),
    ("EISNAM", "errno.EISNAM"),
    ("EREMOTEIO", "errno.EREMOTEIO"),
    ("EDQUOT", "errno.EDQUOT"),
    # Python fcntl library
    ("fcntl", "fcntl.fcntl"),
    ("flock", "fcntl.lockf"),
    ("lockf", "fcntl.lockf"),
    ("LOCK_UN", "fcntl.LOCK_UN"),
    ("LOCK_EX", "fcntl.LOCK_EX"),
    ("LOCK_SH", "fcntl.LOCK_SH"),
    ("LOCK_NB", "fcntl.LOCK_NB"),
    # Python getpass library
    ("getpass", "getpass.getpass"),
    # Python glob library
    ("glob", "glob.glob"),	# Calling conventions differ
    # Python grp library
    ("getgrgid", "grp.getgrgid"),
    ("getgrnam", "grp.getgrnam"),
    # Python math library
    ("acos", "math.acos"),
    ("asin", "math.asin"),
    ("atan", "math.atan"),
    ("atan2", "math.atan2"),
    ("ceil", "math.ceil"),
    ("cos", "math.cos"),
    ("cosh", "math.cosh"),
    ("exp", "math.exp"),
    ("fabs", "math.fabs"),
    ("floor", "math.floor"),
    ("fmod", "math.fmod"),
    ("frexp", "math.frexp"),	# Calling conventions differ
    ("ldexp", "math.ldexp"),
    ("log10", "math.log10"),
    ("log", "math.log"),
    ("modf", "math.modf"),	# Calling conventions differ
    ("pow", "math.pow"),
    ("sinh", "math.sinh"),
    ("sin", "math.sin"),
    ("sqrt", "math.sqrt"),
    ("tan", "math.tan"),
    ("tanh", "math.tanh"),
    # Python os library
    ("abort", "os.abort"),
    ("access", "os.access"),
    ("chdir", "os.chdir"),
    ("close", "os.close"),
    ("environ", "os.environ"),
    ("fchdir", "os.fchdir"),
    ("chroot", "os.chroot"),
    ("chmod", "os.chmod"),
    ("chown", "os.chown"),
    ("ctermid", "os.ctermid"),
    ("dup", "os.dup"),
    ("dup2", "os.dup2"),
    ("execl", "os.execl"),
    ("execle", "os.execle"),
    ("execlp", "os.execlp"),
    ("execlpe", "os.execlpe"),
    ("execv", "os.execv"),
    ("execve", "os.execve"),
    ("execvp", "os.execvp"),
    ("execvpe", "os.execvpe"),
    ("_exit", "os._exit"),
    ("exit", "os.exit"),
    ("fdopen", "os.fdopen"),
    ("fork", "os.fork"),
    ("fsync", "os.fsync"),
    ("ftruncate", "os.ftruncate"),
    ("getcwd", "os.getcwd"),
    ("getegid", "os.getegid"),
    ("geteuid", "os.geteuid"),
    ("getenv", "os.getenv"),
    ("getgid", "os.getgid"),
    ("getgroups", "os.getgroups"),
    ("getlogin", "os.getlogin"),
    ("getpgid", "os.getpgid"),
    ("getpgrp", "os.getpgrp"),
    ("getpid", "os.getpid"),
    ("getppid", "os.getppid"),
    ("getuid", "os.getuid"),
    ("kill", "os.kill"),
    ("killpg", "os.killpg"),
    ("isatty", "os.isatty"),
    ("lseek", "os.lseek"),
    ("lchown", "os.lchown"),
    ("getcwd", "os.getcwd"),
    ("lstat", "os.lstat"),
    ("mkfifo", "os.mkfifo"),
    ("mknod", "os.mknod"),
    ("mkdir", "os.mkdir"),
    ("nice", "os.nice"),
    ("open", "os.open"),
    ("pathconf", "os.pathconf"),
    ("pipe", "os.pipe"),
    ("plock", "os.plock"),
    ("putenv", "os.putenv"),
    ("read", "os.read"),
    ("rmdir", "os.rmdir"),
    ("setegid", "os.setegid"),
    ("seteuid", "os.seteuid"),
    ("setgid", "os.setgid"),
    ("setgroups", "os.setgroups"),
    ("setpgrp", "os.setpgrp"),
    ("setpgid", "os.setpgid"),
    ("setreuid", "os.setreuid"),
    ("setregid", "os.setregid"),
    ("setsid", "os.setsid"),
    ("setuid", "os.setuid"),
    ("strerror", "os.strerror"),
    ("umask", "os.umask"),
    ("symlink", "os.symlink"),
    ("system", "os.system"),
    ("tcgetpgrp", "os.tcgetpgrp"),
    ("tcsetpgrp", "os.tcsetpgrp"),
    ("tmpfile", "os.tmpfile"),
    ("ttyname", "os.ttyname"),
    ("unlink", "os.unlink"),
    ("write", "os.write"),
    ("wait", "os.wait"),
    ("waitpid", "os.waitpid"),
    ("WNOHANG", "os.WNOHANG"),
    ("WCONTINUED", "os.WCONTINUED"),
    ("WUNTRACED", "os.WUNTRACED"),
    ("WCOREDUMP", "os.WCOREDUMP"),
    ("WIFCONTINUED", "os.WIFCONTINUED"),
    ("WIFSTOPPED", "os.WIFSTOPPED"),
    ("WIFSIGNALED", "os.WIFSIGNALED"),
    ("WIFEXITED", "os.WIFEXITED"),
    ("WEXITSTATUS", "os.WEXITSTATUS"),
    ("WSTOPSIG", "os.WSTOPSIG"),
    ("WTERMSIG", "os.WTERMSIG"),
    ("O_RDONLY", "os.O_RDONLY"),
    ("O_WRONLY", "os.O_WRONLY"),
    ("O_RDWR", "os.O_RDWR"),
    ("O_NDELAY", "os.O_NDELAY"),
    ("O_NONBLOCK", "os.O_NONBLOCK"),
    ("O_APPEND", "os.O_APPEND"),
    ("O_DSYNC", "os.O_DSYNC"),
    ("O_RSYNC", "os.O_RSYNC"),
    ("O_SYNC", "os.O_SYNC"),
    ("O_NOCTTY", "os.O_NOCTTY"),
    ("O_CREAT", "os.O_CREAT"),
    ("O_EXCL", "os.O_EXCL"),
    ("O_TRUNC", "os.O_TRUNC"),
    ("F_OK", "os.F_OK"),
    ("R_OK", "os.R_OK"),
    ("W_OK", "os.W_OK"),
    ("X_OK", "os.X_OK"),
    ("S_ISUID", "os.S_ISUID"),
    ("S+ISGID", "os.S+ISGID"),
    ("S_ENFMT", "os.S_ENFMT"),
    ("S_ISVTX", "os.S_ISVTX"),
    ("S_IREAD", "os.S_IREAD"),
    ("S_IWRITE", "os.S_IWRITE"),
    ("S_IEXEC", "os.S_IEXEC"),
    ("S_IRWXU", "os.S_IRWXU"),
    ("S_IRUSR", "os.S_IRUSR"),
    ("S_IXUSR", "os.S_IXUSR"),
    ("S_IRWXG", "os.S_IRWXG"),
    ("S_IRGRP", "os.S_IRGRP"),
    ("S_IWGRP", "os.S_IWGRP"),
    ("S_IXGRP", "os.S_IXGRP"),
    ("S_IRWXO", "os.S_IRWXO"),
    ("S_IROTH", "os.S_IROTH"),
    ("S_IWOTH", "os.S_IWOTH"),
    ("S_IXOTH", "os.S_IXOTH"),
    # Python random library -- alas, C rand() doesn't map cleanly
    ("srand48", "random.seed"),
    ("srand", "random.seed"),
    # Python os.path library
    ("basename", "os.path.basename"),
    ("dirname", "os.path.dirname"),
    # Python string library
    ("toupper", "string.upper"),
    ("tolower", "string.lower"),
    # Python sys library
    ("argv", "sys.argv"),
    ("stdin", "sys.stdin"),
    ("stdout", "sys.stdout"),
    ("stderr", "sys.stderr"),
)

# These are C functions that need to turn into method calls on their first arg
methodmappings = (
    # File objects
    ("fclose", "close", None),
    ("fflush", "flush", None),
    ("fileno", "fileno", None),
    ("fprintf", "write", None),
    ("fseek", "seek", None),
    ("ftell", "tell", None),
    ("ftruncate", "truncate", None),
    # Curses library.  This is all the methods on the Windows Objects page.
    # FIXME: curses mapping is far from complete
    ("waddch",  "addch", "curses"),
    ("waddnstr", "addnstr", "curses"),
    ("waddstr", "addstr", "curses"),
    ("wattroff", "attroff", "curses"),
    ("wattron", "attron", "curses"),
    ("wattrset", "attrset", "curses"),
    ("wbkgd", "bkgd", "curses"),
    ("wbkgdset", "bkgdset", "curses"),
    ("wborder", "border", "curses"),
    ("wbox", "box", "curses"),
    ("wclear", "clear", "curses"),
    ("clearok", "clearok", "curses"),	# No w prefix
    ("wclrtobot", "clrtobot", "curses"),
    ("wclrtoeol", "clrtoeol", "curses"),
    ("wcursyncup", "cursyncup", "curses"),
    ("wdelch", "delch", "curses"),
    ("wdeleteln", "deleteln", "curses"),
    ("derwin", "derwin", "curses"),	# No w prefix
    ("wechochar", "echochar", "curses"),
    ("wenclose", "enclose", "curses"),
    ("werase", "erase", "curses"),
    ("getbegyx", "getbegyx", "curses"),	# No w prefix
    ("wgetch", "getch", "curses"),
    ("getkey", "getkey", "curses"),	# No w prefix
    ("getmaxyx", "getmaxyx", "curses"),	# No w prefix, calling convention differs
    ("getparyx", "getparyx", "curses"),	# No w prefix
    ("wgetstr", "getstr", "curses"),
    ("getyx", "getyx", "curses"),		# No w prefix. calling convention differ)s
    ("whline", "hline", "curses"),
    ("idcok", "idcok", "curses"),		# No w prefix
    ("idlok", "idlok", "curses"),		# No w prefix
    ("immedok", "immedok", "curses"),	# No w prefix
    ("winch", "inch", "curses"),
    ("winsch", "insch", "curses"),
    ("winsdelln", "insdelln", "curses"),
    ("winsertln", "insertln", "curses"),
    ("winsnstr", "insnstr", "curses"),
    ("winsstr", "insstr", "curses"),
    ("winstr", "instr", "curses"),
    ("is_linetouched", "is_linetouched", "curses"),	# No w prefix
    ("is_wintouched", "is_wintouched", "curses"),		# No w prefix
    ("keypad", "keypad", "curses"),	# No w prefix
    ("leaveok", "leaveok", "curses"),	# No w prefix
    ("wmove", "move", "curses"),
    ("mvderwin", "mvderwin", "curses"),	# No w prefix
    ("wmvwin", "mvwin", "curses"),
    ("nodelay", "nodelay", "curses"),	# No w prefix
    ("notimeout", "notimeout", "curses"),	# No w prefix
    ("wnoutrefresh", "noutrefresh", "curses"),
    ("overlay", "overlay", "curses"),	# No w prefix
    ("overwrite", "overwrite", "curses"),	# No w prefix
    ("putwin", "putwin", "curses"),	# No w prefix
    ("wredrawln", "redrawln", "curses"),	# No w prefix
    ("redrawwin", "redrawwin", "curses"),	# No w prefix
    ("wrefresh", "refresh", "curses"),	# No w prefix
    ("wscroll", "scroll", "curses"),
    ("wsetscrreg", "setscrreg", "curses"),
    ("wscrollok", "scrollok", "curses"),
    ("wstandend", "standend", "curses"),
    ("wstandout", "standout", "curses"),
    ("subpad", "subpad", "curses"),	# No w prefix
    ("wsubwin", "subwin", "curses"),
    ("wsyncdown", "syncdown", "curses"),
    ("syncok", "syncok", "curses"),	# No w prefix
    ("wsyncup", "syncup", "curses"),
    ("wtimeout", "timeout", "curses"),
    ("wtouchline", "touchline", "curses"),
    ("wtouchwin", "touchwin", "curses"),
    ("untouchwin", "untouchwin", "curses"),	# No w prefix
    ("wvline", "vline", "curses"),
    )

falsefriends = (
    "frexp", "getsyx", "getmaxyx", "glob", "ioctl", "modf",
    )

# These have to be applied to the entire file without breaking it into regions
file_transformations = (
    # Simple initializers to tuples
    (r"(?:static)?\s+(?:%(type)s|%(class)s)\s+(%(id)s)\[[a-zA-Z0-9._]*]\s*=\s*{([^}]+)}",
     r"\1 = (\2)"),
    (r"enum\s+(%(id)s\s*){\s*",  r"enum \1{\n"),
    (r"enum\s+{\s*",  r"enum {\n"),
    (r"%(ind)s#\s*\$ctopy.*", ""),	# Make hints go away
    (r"(?:int )?main\(int\s+argc,\s+char\s+\*argv\)\s*{",
     "if __name__ == '__main__':"),
    )

# These need to be applied repeatedly within regions.
# They rely on semicolons as statatement end markers.
repeat_transformations = (
    (
    # Group 1: What we're doing here is stripping out prefix, suffix,
    # and wrapper parts of declarations in order to reduce everything
    # to base type followed by whitespace followed by id.  This is
    # significant for simplifying both function formal parameter lists
    # and variable declaration lines.  We'll get rid of the remaining
    # type stuff in a later pass.
    (r"(%(type)s|%(class)s)\s*\*", r"\1 "),	# Pointer type decls
    (r"(%(type)s|%(class)s)(.*), \*", r"\1\2, "),	# Pointer type decls
    (r"(%(type)s|%(class)s)\s*\((%(id)s)\)\(\)", r"\1 \2"),	# Function pointer wrappers
    (r"(%(type)s|%(class)s)\s*(%(id)s)\[\]", r"\1 \2"),	# Array declarators
    ),
    (
    # Group 2: Translate function headers.  This needs to happen after
    # reduction to base types (just above) but before scalar types
    # have been removed entirely.
    (r"\n(?:static\s+)?(?:%(type)s|%(class)s) +(.*\)) *\n", r"\ndef \1:\n"),
    ),
    (
    # Group 3: What we're doing here is trying to get rid of variable
    # declarations that don't have initializer parts.
    # Scalar-vars just after the type and before a comma go away.
    (r"(\n[ \t]*(?:%(type)s))(\s*%(id)s),", r"\1 "),
    # Scalar-vars just after type and before a semi go away, but semi stays.
    (r"(\n[ \t]*(?:%(type)s))(\s*%(id)s);", r"\1;"),
    # Class-vars after class names and before comma or semi get an initializer.
    (r"(\n[ \t]*)(%(class)s)(\s*%(id)s)([;,])", r"\1\2\3 = \2()\4"),
    # Scalar-vars between a comma and a trailing semicolon go away.
    (r"(\n[ \t]*)((?:%(type)s).*)(,\s*%(id)s\s*);", r"\1\2;"),
    # Class-Vars between comma and semicolon get a following initializer 
    (r"(\n[ \t]*)(%(class)s)(.*,\s)*(%(id)s)(\s*;)", r"\1\2\3\4 = \2()\5"),
    # Scalar-vars between commas in a declaration line go away.
    (r"(\n[ \t]*(?:%(type)s)\s+.*)(,\s*%(id)s)(,.*);", r"\1\3;"),
    # Bare class-vars between commas get an initializer
    (r"(\n[ \t]*)(%(class)s)(\s+.*,)(\s*%(id)s),(.*);",r"\1\2\3\4 = \2(),\5;"),
    # Any declaration line not containing an initializer goes away.
    (r"\n[ \t]*(?:%(type)s|%(class)s)[^=;]*;", ""),
    ),
    (
    # Group 4: At this point all declarations left have initializers.
    # Replace commas in declaration lines with semis, otherwise Python will
    # barf later because it thinks that, e.g., a=4, b=5  is an attempt to
    # assign a constant to a tuple.
    # FIXME: This will fail messily on GCC structure intializers.
    (r"(\n[ \t]*(?:%(type)s|%(class)s).*),(.*);", r"\1;\2"),
    ),
    (
    # Group 5: Now rip out all remaining base type information.
    # This will strip remaining type declarators out of formal parameter lists.
    # It will also remove types from the beginning of declaration lines.
    # Won't nuke casts because it looks for at least one following whitespace.
    (r"(?:%(type)s|%(class)s)[\s;]\s*", ""),
    ),
)

# These get applied once within regions, before type info has been stripped
pre_transformations = (
    # We used to do function header translation here.   We leave
   # this in place because we'll probably need to do things here again.
    )

# These get applied once within regions, after type info has been stripped
post_transformations = (
    # some consequences of having translated function headers
    (r"\(void\):\n", r"():\n"),
    (r"def(.*):\n\Z", r"def\1:\n    "),	# indent comment on line after def
    # externs can just disappear -- this may discard a following comment
    (r"extern[^;]+;.*\n", r""),
    # macros
    (r"#define\s+(%(id)s)\s+(.*)", r"\1\t= \2"),
    (r"#define\s+(%(id)s)\(([^)]*)\)\s+(.*\))", r"def \1(\2):\treturn \3"),
    (r"#define\s+(%(id)s)\(([^)]*)\)\s+([^(].*)", r"def \1(\2):\t\3"),
    # control structure
    (r"\bif *\((.*)\)(\s*{)?", r"if \1:"),
    (r"\bwhile *\((.*)\)(\s*{)?", r"while \1:"), 
    (r"\bwhile 1:", r"while True:"),
    (r"\bfor \(;;\)(\s*{)?", r"while True:"),
    (r"\bfor \((%(id)s) *= *0; *\1 *<= *([^;]+); *\1\+\+\)(\s*{)?",
     					r"for \1 in range(\2+1):"),
    (r"\bfor \((%(id)s) *= *(\w+); *\1 *<= *([^;]+); *\1\+\+\)(\s*{)?",
     					r"for \1 in range(\2, \3+1):"),
    (r"\bfor \((%(id)s) *= *0; *\1 *< *([^;]+); *\1\+\+\)\s*{",
     					r"for \1 in range(\2):"),
    (r"\bfor \((%(id)s) *= *(\w+); *\1 *< *([^;]+); *\1\+\+\)(\s*{)?",
     					r"for \1 in range(\2, \3):"),
    (r"else if", r"elif"),
    (r"(?:} )?else\s*{", r"else"),
    (r"(?<!#)else", r"else:"),
    (r"switch *\((.*)\)(\s*{)?", r"switch \1:"),# Not Python, but less ugly
    # constants
    (r"\btrue\b", r"True"),	# C99
    (r"\bfalse\b", r"False"),	# C99
    (r"\bTRUE\b", r"True"),	# pre-C99
    (r"\bFALSE\b", r"False"),	# pre-C99
    # expression operations
    (r" *\&\& *", r" and "),
    (r" *\|\| *", r" or "),
    (r"-\>", "."),
    (r"!(?!=) *", "not "),
    (r"(and|or) *\n", r"\1 \\\n"),
    # most common uses of address operator
    (r"return *&", "return "),
    (r"= *&", "= "),
    # increment and decrement statements
    (r"(%(id)s)\+\+([;\n])", r"\1 += 1\2"),
    (r"(%(id)s)--([;\n])", r"\1 -= 1\2"),
    (r"\+\+(%(id)s)([;\n])", r"\1 += 1\2"),
    (r"--(%(id)s)([;\n])", r"\1 -= 1\2"),
    # no-op voids
    (r"\n[ \t]*\(void\)", r"\n"),  
    # C functions that turn into Python builtins
    (r"\batoi\(", r"int("),
    (r"\batof\(", r"float("),
    (r"\batol\(", r"long("),
    (r"\bfopen\(", r"open("),
    (r"\bputchar\(", "stdout.write("),
    (r"\bgetchar\(\)", "stdout.read(1)"),
    (r"\bstrlen\(", r"len("),
    (r"\bstrcmp\((%(exp)s),\s*(%(exp)s)\)\s*==\s*0", r"\1 == \2"),
    (r"\bstrcmp\((%(exp)s),\s*(%(exp)s)\)\s*!=\s*0", r"\1 != \2"),
    (r"\bstrcpy\((%(exp)s),\s*(%(exp)s)\)", r"\1 = \2"),
    # Python time library
    (r"\btime\(NULL\)", r"time.time()"),
    # well-known includes
    (r"#include \<string.h\>\n", ""),
    (r"#include \<stdlib.h\>\n", ""),
    (r"#include \<stdbool.h\>\n", ""),
    (r"#include \<stdio.h\>\n", "import sys\n"),
    (r"#include \<math.h\>\n", r"import math\n"),
    (r"#include \<time.h\>\n", r"import time\n"),
    (r"#include \<regex.h\>\n", r"import re\n"),
    (r"#include \<curses.h\>\n", r"import curses\n"),
)

final_transformations = (
    # block delimiters -- do these as late as possible, they're useful
    (r";(%(eol)s)", r"\1"),
    (r"\n[ \t]*}%(eol)s", r""),
    (r"(?<!=\n)\n{\n", "\n"),	# Start-of-line brace that's not an initializer
    (r"%% \(,(%(ind)s)", r"%\1("),
    )

def single_apply(transforms, text):
    "Apply specified set of transformations once."
    for (fro, to) in transforms:
        oldtext = text
        # Prepending \n then stripping it means that \n can reliably
        # be used to recognize start of line.
        text = re.sub(fro % shorthands, to, "\n" + oldtext)[1:]
        if debug >= 2 and text != oldtext:
            print "%s transforms '%s' to '%s'" % ((fro, to), `oldtext`, `text`)
    return text

def repeat_apply(transforms, text):
    "Repeatedly apply specified transformations to text until it's stable."
    while True:
        transformed = single_apply(transforms, text)
        if transformed != text:
            text = transformed
        else:
            break
    return text

def ctopy(input):
    "Transform C to Python."
    if debug >= 2:
        print "Gathering hints"
    hints = re.finditer(r"\$ctopy (.*)", input)
    for hint in hints:
        process_hint(hint.group(1))
    if debug >= 2:
        print "Processing inline enums"
    global stringify
    enums = re.finditer(r"enum[ \t]*{(.*)} (%(id)s)" % shorthands, input)
    for instance in enums:
        stringify += instance.group(1).replace(" ", "").split(",")
        input = input[:instance.start(0)] + input[instance.start(2):]
    if debug:
        print "Pre-transformations begin"
    input = repeat_apply(file_transformations, input)
    if debug >= 2:
        print "After pre-transformations: %s" % `code`
    if debug:
        print "Region analysis begins"
    boundaries = [0]
    state = "text"
    for i in range(len(input)):
        if state == "text":
            if input[i] == '"' and (i == 0 or input[i-1] != '\\'):
                if debug >= 2:
                    print "String literal starts at %d" % i
                boundaries.append(i)
                state = "stringliteral"
            elif input[i:i+2] == "/*":
                if debug >= 2:
                    print "Closed comment starts at %d" % (i-1)
                boundaries.append(i)
                state = "closedcomment"
            elif input[i:i+2] == "//":
                if debug >= 2:
                    print "Open comment starts at %d" % i
                boundaries.append(i)
                state = "opencomment"
            elif input[i:].startswith("typedef enum {") or input[i:].startswith("enum {"):
                if debug >= 2:
                    print "enumeration starts at %d" % i
                if input[i-2:i+1] != 'f e':
                    boundaries.append(i)
                boundaries.append(i + input[i:].find("enum") + 5)
            elif input[i:].startswith("\n}"):
                if debug >= 2:
                    print "start-of-line brace at %d" % i
                boundaries.append(i)
                boundaries.append(i+2)
        elif state == "stringliteral":
            if input[i] == '"' and (i == 0 or input[i-1] != '\\'):
                if debug >= 2:
                    print "String ends at %d" % i
                boundaries.append(i+1)
                state = "text"
        elif state == "closedcomment":
            if input[i:i+2] == "*/":
                if debug >= 2:
                    print "closed comment ends at %d" % (i+1)
                boundaries.append(i+2)
                state = "text"                
        elif state == "opencomment":
            if input[i] == "\n":
                if debug >= 2:
                    print "Open comment ends at %d" % (i+1)
                boundaries.append(i+1)
                state = "text"
    boundaries.append(len(input))
    if debug >= 2:
        print "Boundaries:", boundaries
    regions = []
    for i in range(len(boundaries)-1):
        regions.append(input[boundaries[i]:boundaries[i+1]])
    regions = filter(lambda x: x != '', regions)
    if debug:
        print "Regexp transformation begins"
    if debug:
        import pprint
        pp = pprint.PrettyPrinter(indent=4)
        print "Regions:"
        pp.pprint(regions)
    if debug >= 2:
        print "Processing printf-like functions"
    for (i, here) in enumerate(regions):
        if regions[i][0] != '"' or not "%" in here:
            continue
        else:
            for func in printflike:
                if re.search(r"\b%s\([^;]*\Z" % func, regions[i]):
                    break
                else:
                    continue	# Didn't find printf-like function
        # Found printf-like function.  Replace first comma in the
        # argument region with " % (".  This copes gracefully with the
        # case where the format string is wrapped in _( ) for
        # initialization.
        regions[i+1] = re.sub(r",\s*", r" % (", regions[i+1], 1)
        j = regions[i+1].find("%") + 2
        parenlevel = 0
        while j < len(regions[i+1]):
            if regions[i+1][j] == "(":
                parenlevel += 1
            if regions[i+1][j] == ")":
                parenlevel -= 1
            if parenlevel == 0:
                regions[i+1] = regions[i+1][:j] + ")" + regions[i+1][j:]
                break
            j += 1
    importlist = []
    try:
        for i in range(len(regions)):
            if regions[i][:2] == "/*":
                if regions[i].count("\n") <= 1:		# winged comment
                    regions[i] = "#" + regions[i][2:-2]
                elif re.search("/\*+\n", regions[i]):	# boxed comment
                    regions[i] = re.sub(r"\n([ \t]*) \* ?", r"\n\1",regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)\*", r"\n\1", regions[i])
                    regions[i] = re.sub(r"^([ \t]*)/\*+\n", r"\1#\n", regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)\**/", r"\n\1", regions[i])
                    regions[i] = re.sub(r"\n([ \t]*)(?!#)", r"\n\1# ", regions[i])
                else:
                    regions[i] = regions[i].replace("/*", "#")
                    regions[i] = regions[i].replace("\n*/", "\n#")
                    regions[i] = regions[i].replace("*/", "")
                    regions[i] = regions[i].replace("\n *", "\n")
                    regions[i] = regions[i].replace("\n", "\n#")
            elif regions[i][:2] == "//":
                regions[i] = "#" + regions[i][2:]
            elif regions[i][0] != '"':
                if debug >= 2:
                    print "Doing pre transformations"
                regions[i] = single_apply(pre_transformations, regions[i])
                if debug >= 2:
                    print "Doing repeated transformations"
                for (j, hack) in enumerate(repeat_transformations):
                    if debug >= 2:
                        print "Repeat transformations group %d" % (j+1)
                    regions[i] = repeat_apply(hack, regions[i])
                if debug:
                    print "Function and method mappings begin"
                for (fro, to) in funmappings:
                    if re.search(r"\b" + fro + r"\b", regions[i]):
                        regions[i] = re.sub(r"\b" + fro + r"\b", to, regions[i])
                        (module, function) = to.split(".")
                        if module not in importlist and module:
                            importlist.append(module)
                for (fro, to, module) in methodmappings:
                    if re.search(r"\b" + fro + r"\b\(", regions[i]):
                        singlearg = r"\b"+fro+(r"\b\((%(exp)s)\)"%shorthands)
                        if re.search(singlearg, regions[i]):
                            regions[i] = re.sub(singlearg,
                                                r"\1." + to +"()",
                                                regions[i])
                        else:
                            regions[i] = re.sub(r"\b"+fro+r"\b\(([^,]*),\s*",
                                                r"\1." + to + "(",
                                                regions[i])
                        if module not in importlist and module:
                            importlist.append(module)
                for name in falsefriends:
                    if re.search(r"\b" + name + r"\b\(", regions[i]):
                        sys.stderr.write("warning: %s calling conventions differ between C and Python." % name)
                if debug >= 2:
                    print "Doing post transformations"
                regions[i] = single_apply(post_transformations, regions[i])
                for str in stringify:
                    regions[i] = re.sub(r"\b" + str + r"\b",
                                        '"' + str + '"', regions[i])
    except IndexError:
        sys.stderr.write("ctopy: pathological string literal at %d.\n" % boundaries[i])
        raise SystemExit, 1
    if debug:
        "Enumeration processing"
    state = "plain"
    for (i, region) in enumerate(regions):
        # first compute a parse state
        if region.startswith("typedef enum"):
            state = "typedef"
        elif region.startswith("enum"):
            state = "enum"
        elif region == "\n}":
            if state in ("typedef", "enum"):
                regions[i] = ''
                state = "plain"
        # now do something useful with it
        if debug >= 3:
            print "Enumeration processing: state = %s, region = %s" % (state, `regions[i]`)
        if state in ("enum", "typedef"):
            if regions[i] == "enum ":
                m = re.match("(%(id)s) {" % shorthands, regions[i+1])
                if m:
                    shorthands['type'] += "|" + m.group(1)
                    regions[i] = '# From enumerated type \'%s\'\n' % m.group(1)
                    regions[i+1] = regions[i+1][m.end(0)+1:]
                else: 
                    regions[i] = '# From anonymous enumerated type\n'
            elif regions[i] == "typedef enum ":
                m = re.match("\s* (%(id)s)\s*;?" % shorthands, regions[i+3])
                if m:
                    shorthands['type'] += "|" + m.group(1)
                    regions[i] = '# From enumerated type \'%s\'\n' % m.group(1)
                    regions[i+3] = regions[i+3][:m.start(0)] + "\n\n"
                else: 
                    regions[i] = '# From anonymous typedefed enum (?!)\n'
            else:
                regions[i] = re.sub(",\s*", "\n", regions[i])
                val = 0
                txt = regions[i].split("\n")
                for j in range(len(txt)):
                    if txt[j] == '' or txt[j].startswith("{"):
                        pass
                    elif '=' not in txt[j]:
                        txt[j] += " = %d" % val
                        val += 1
                regions[i] = "\n".join(txt)
    if debug:
        "Final transformations begin"
    regions = map(lambda r: repeat_apply(final_transformations, r),regions)
    text = "".join(regions)
    if importlist:
        importlist = "import " + ", ".join(importlist) + "\n"
        text = importlist + text
    # Emit what we got.  Preserve imports in case this is a .h file 
    return text

def process_hint(line):
    "Process a translation-hints line."
    if line[0] == "#":
        pass
    else:
        global stringify, printflike
        if debug >= 2:
            print "Hint: %s" % `line`
        lst = line.replace(",", " ").split()
        if lst[0] == "stringify":
            stringify += lst[1:]
        elif lst[0] == "type":
            for tok in lst[1:]:
                shorthands["type"] += r"|\b" + tok + r"\b" 
        elif lst[0] == "class":
            for tok in lst[1:]:
                shorthands["class"] += r"|\b" + tok + r"\b"
        elif lst[0] == "printflike":
            printflike += lst[1:]

if __name__ == "__main__":
    import getopt
    (options, arguments) = getopt.getopt(sys.argv[1:], "c:h:ds:t:")
    debug = 0;
    for (switch, val) in options:
	if (switch == '-c'):
            shorthands["class"] += r"|\b" + val + r"\b"
	elif (switch == '-d'):
	    debug += 1
	elif (switch == '-h'):
            for line in open(val):
                process_hint(line)
	elif (switch == '-s'):
            stringify.append(val)
	elif (switch == '-t'):
            shorthands["type"] += r"|\b" + val + r"\b" 

    code = sys.stdin.read()
    if debug >= 2:
        print "Input is: %s" % `code`
    text = ctopy(code)
    if debug:
        print "Output:"
    sys.stdout.write(text)
